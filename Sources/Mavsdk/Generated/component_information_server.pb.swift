// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: component_information_server.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Meta information for parameter of type float.
struct Mavsdk_Rpc_ComponentInformationServer_FloatParam {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name (max 16 chars)
  var name: String = String()

  /// Short description
  var shortDescription: String = String()

  /// Long description
  var longDescription: String = String()

  /// Unit
  var unit: String = String()

  /// Decimal places for user to show
  var decimalPlaces: Int32 = 0

  /// Current/starting value
  var startValue: Float = 0

  /// Default value
  var defaultValue: Float = 0

  /// Minimum value
  var minValue: Float = 0

  /// Maximum value
  var maxValue: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_ComponentInformationServer_ProvideFloatParamRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Float param definition
  var param: Mavsdk_Rpc_ComponentInformationServer_FloatParam {
    get {return _param ?? Mavsdk_Rpc_ComponentInformationServer_FloatParam()}
    set {_param = newValue}
  }
  /// Returns true if `param` has been explicitly set.
  var hasParam: Bool {return self._param != nil}
  /// Clears the value of `param`. Subsequent reads from it will return its default value.
  mutating func clearParam() {self._param = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _param: Mavsdk_Rpc_ComponentInformationServer_FloatParam? = nil
}

struct Mavsdk_Rpc_ComponentInformationServer_ProvideFloatParamResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var componentInformationServerResult: Mavsdk_Rpc_ComponentInformationServer_ComponentInformationServerResult {
    get {return _componentInformationServerResult ?? Mavsdk_Rpc_ComponentInformationServer_ComponentInformationServerResult()}
    set {_componentInformationServerResult = newValue}
  }
  /// Returns true if `componentInformationServerResult` has been explicitly set.
  var hasComponentInformationServerResult: Bool {return self._componentInformationServerResult != nil}
  /// Clears the value of `componentInformationServerResult`. Subsequent reads from it will return its default value.
  mutating func clearComponentInformationServerResult() {self._componentInformationServerResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _componentInformationServerResult: Mavsdk_Rpc_ComponentInformationServer_ComponentInformationServerResult? = nil
}

/// A float param that has been updated.
struct Mavsdk_Rpc_ComponentInformationServer_FloatParamUpdate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name of param that changed
  var name: String = String()

  /// New value of param
  var value: Float = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_ComponentInformationServer_SubscribeFloatParamRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mavsdk_Rpc_ComponentInformationServer_FloatParamResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A param update
  var paramUpdate: Mavsdk_Rpc_ComponentInformationServer_FloatParamUpdate {
    get {return _paramUpdate ?? Mavsdk_Rpc_ComponentInformationServer_FloatParamUpdate()}
    set {_paramUpdate = newValue}
  }
  /// Returns true if `paramUpdate` has been explicitly set.
  var hasParamUpdate: Bool {return self._paramUpdate != nil}
  /// Clears the value of `paramUpdate`. Subsequent reads from it will return its default value.
  mutating func clearParamUpdate() {self._paramUpdate = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _paramUpdate: Mavsdk_Rpc_ComponentInformationServer_FloatParamUpdate? = nil
}

/// Result type.
struct Mavsdk_Rpc_ComponentInformationServer_ComponentInformationServerResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Result enum value
  var result: Mavsdk_Rpc_ComponentInformationServer_ComponentInformationServerResult.Result = .unknown

  /// Human-readable English string describing the result
  var resultStr: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Possible results returned for param requests.
  enum Result: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Unknown result
    case unknown // = 0

    /// Request succeeded
    case success // = 1

    /// Duplicate param
    case duplicateParam // = 2

    /// Invalid start param value
    case invalidParamStartValue // = 3

    /// Invalid default param value
    case invalidParamDefaultValue // = 4

    /// Invalid param name
    case invalidParamName // = 5

    /// No system is connected
    case noSystem // = 6
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .success
      case 2: self = .duplicateParam
      case 3: self = .invalidParamStartValue
      case 4: self = .invalidParamDefaultValue
      case 5: self = .invalidParamName
      case 6: self = .noSystem
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .success: return 1
      case .duplicateParam: return 2
      case .invalidParamStartValue: return 3
      case .invalidParamDefaultValue: return 4
      case .invalidParamName: return 5
      case .noSystem: return 6
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Mavsdk_Rpc_ComponentInformationServer_ComponentInformationServerResult.Result: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Mavsdk_Rpc_ComponentInformationServer_ComponentInformationServerResult.Result] = [
    .unknown,
    .success,
    .duplicateParam,
    .invalidParamStartValue,
    .invalidParamDefaultValue,
    .invalidParamName,
    .noSystem,
  ]
}

#endif  // swift(>=4.2)

#if swift(>=5.5) && canImport(_Concurrency)
extension Mavsdk_Rpc_ComponentInformationServer_FloatParam: @unchecked Sendable {}
extension Mavsdk_Rpc_ComponentInformationServer_ProvideFloatParamRequest: @unchecked Sendable {}
extension Mavsdk_Rpc_ComponentInformationServer_ProvideFloatParamResponse: @unchecked Sendable {}
extension Mavsdk_Rpc_ComponentInformationServer_FloatParamUpdate: @unchecked Sendable {}
extension Mavsdk_Rpc_ComponentInformationServer_SubscribeFloatParamRequest: @unchecked Sendable {}
extension Mavsdk_Rpc_ComponentInformationServer_FloatParamResponse: @unchecked Sendable {}
extension Mavsdk_Rpc_ComponentInformationServer_ComponentInformationServerResult: @unchecked Sendable {}
extension Mavsdk_Rpc_ComponentInformationServer_ComponentInformationServerResult.Result: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "mavsdk.rpc.component_information_server"

extension Mavsdk_Rpc_ComponentInformationServer_FloatParam: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FloatParam"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "short_description"),
    3: .standard(proto: "long_description"),
    4: .same(proto: "unit"),
    5: .standard(proto: "decimal_places"),
    6: .standard(proto: "start_value"),
    7: .standard(proto: "default_value"),
    8: .standard(proto: "min_value"),
    9: .standard(proto: "max_value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.shortDescription) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.longDescription) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.unit) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.decimalPlaces) }()
      case 6: try { try decoder.decodeSingularFloatField(value: &self.startValue) }()
      case 7: try { try decoder.decodeSingularFloatField(value: &self.defaultValue) }()
      case 8: try { try decoder.decodeSingularFloatField(value: &self.minValue) }()
      case 9: try { try decoder.decodeSingularFloatField(value: &self.maxValue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.shortDescription.isEmpty {
      try visitor.visitSingularStringField(value: self.shortDescription, fieldNumber: 2)
    }
    if !self.longDescription.isEmpty {
      try visitor.visitSingularStringField(value: self.longDescription, fieldNumber: 3)
    }
    if !self.unit.isEmpty {
      try visitor.visitSingularStringField(value: self.unit, fieldNumber: 4)
    }
    if self.decimalPlaces != 0 {
      try visitor.visitSingularInt32Field(value: self.decimalPlaces, fieldNumber: 5)
    }
    if self.startValue != 0 {
      try visitor.visitSingularFloatField(value: self.startValue, fieldNumber: 6)
    }
    if self.defaultValue != 0 {
      try visitor.visitSingularFloatField(value: self.defaultValue, fieldNumber: 7)
    }
    if self.minValue != 0 {
      try visitor.visitSingularFloatField(value: self.minValue, fieldNumber: 8)
    }
    if self.maxValue != 0 {
      try visitor.visitSingularFloatField(value: self.maxValue, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_ComponentInformationServer_FloatParam, rhs: Mavsdk_Rpc_ComponentInformationServer_FloatParam) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.shortDescription != rhs.shortDescription {return false}
    if lhs.longDescription != rhs.longDescription {return false}
    if lhs.unit != rhs.unit {return false}
    if lhs.decimalPlaces != rhs.decimalPlaces {return false}
    if lhs.startValue != rhs.startValue {return false}
    if lhs.defaultValue != rhs.defaultValue {return false}
    if lhs.minValue != rhs.minValue {return false}
    if lhs.maxValue != rhs.maxValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_ComponentInformationServer_ProvideFloatParamRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProvideFloatParamRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "param"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._param) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._param {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_ComponentInformationServer_ProvideFloatParamRequest, rhs: Mavsdk_Rpc_ComponentInformationServer_ProvideFloatParamRequest) -> Bool {
    if lhs._param != rhs._param {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_ComponentInformationServer_ProvideFloatParamResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProvideFloatParamResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "component_information_server_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._componentInformationServerResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._componentInformationServerResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_ComponentInformationServer_ProvideFloatParamResponse, rhs: Mavsdk_Rpc_ComponentInformationServer_ProvideFloatParamResponse) -> Bool {
    if lhs._componentInformationServerResult != rhs._componentInformationServerResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_ComponentInformationServer_FloatParamUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FloatParamUpdate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if self.value != 0 {
      try visitor.visitSingularFloatField(value: self.value, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_ComponentInformationServer_FloatParamUpdate, rhs: Mavsdk_Rpc_ComponentInformationServer_FloatParamUpdate) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_ComponentInformationServer_SubscribeFloatParamRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscribeFloatParamRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_ComponentInformationServer_SubscribeFloatParamRequest, rhs: Mavsdk_Rpc_ComponentInformationServer_SubscribeFloatParamRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_ComponentInformationServer_FloatParamResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FloatParamResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "param_update"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._paramUpdate) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._paramUpdate {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_ComponentInformationServer_FloatParamResponse, rhs: Mavsdk_Rpc_ComponentInformationServer_FloatParamResponse) -> Bool {
    if lhs._paramUpdate != rhs._paramUpdate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_ComponentInformationServer_ComponentInformationServerResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ComponentInformationServerResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .standard(proto: "result_str"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.result) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.resultStr) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != .unknown {
      try visitor.visitSingularEnumField(value: self.result, fieldNumber: 1)
    }
    if !self.resultStr.isEmpty {
      try visitor.visitSingularStringField(value: self.resultStr, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mavsdk_Rpc_ComponentInformationServer_ComponentInformationServerResult, rhs: Mavsdk_Rpc_ComponentInformationServer_ComponentInformationServerResult) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.resultStr != rhs.resultStr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mavsdk_Rpc_ComponentInformationServer_ComponentInformationServerResult.Result: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RESULT_UNKNOWN"),
    1: .same(proto: "RESULT_SUCCESS"),
    2: .same(proto: "RESULT_DUPLICATE_PARAM"),
    3: .same(proto: "RESULT_INVALID_PARAM_START_VALUE"),
    4: .same(proto: "RESULT_INVALID_PARAM_DEFAULT_VALUE"),
    5: .same(proto: "RESULT_INVALID_PARAM_NAME"),
    6: .same(proto: "RESULT_NO_SYSTEM"),
  ]
}
